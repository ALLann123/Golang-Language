#!/usr/bin/env python3
"""
xor_file.py

Usage:
    python xor_file.py encrypt  infile outfile --key "my passphrase"
    python xor_file.py decrypt  infile outfile --key "my passphrase"
    python xor_file.py encrypt  infile outfile --hex  4a6f686e01...
"""

import argparse
import hashlib
from pathlib import Path

CHUNK_SIZE = 64 * 1024  # 64KB


def derive_key_from_passphrase(passphrase: str, length: int = 32) -> bytes:
    """Derive a key of `length` bytes from passphrase using SHA-256 repeated if needed."""
    h = hashlib.sha256(passphrase.encode('utf-8')).digest()
    if length <= len(h):
        return h[:length]
    # If need longer, hash concatenation (simple KDF for example purposes)
    out = bytearray(h)
    while len(out) < length:
        h = hashlib.sha256(h).digest()
        out.extend(h)
    return bytes(out[:length])


def parse_hex_key(hexstr: str) -> bytes:
    hexstr = hexstr.strip()
    if len(hexstr) % 2 != 0:
        # allow odd length by prepending 0
        hexstr = "0" + hexstr
    return bytes.fromhex(hexstr)


def xor_bytes(data: bytes, key: bytes, offset: int = 0) -> bytes:
    """XOR `data` with `key` repeating. offset is used to continue key position across chunks."""
    out = bytearray(len(data))
    keylen = len(key)
    if keylen == 0:
        raise ValueError("Key must not be empty")
    for i in range(len(data)):
        out[i] = data[i] ^ key[(offset + i) % keylen]
    return bytes(out)


def process_file(infile: Path, outfile: Path, key: bytes):
    """Stream infile -> outfile XOR'ing with key."""
    keylen = len(key)
    pos = 0
    with infile.open('rb') as fin, outfile.open('wb') as fout:
        while True:
            chunk = fin.read(CHUNK_SIZE)
            if not chunk:
                break
            out_chunk = xor_bytes(chunk, key, offset=pos % keylen)
            fout.write(out_chunk)
            pos += len(chunk)


def main():
    p = argparse.ArgumentParser(description="XOR encrypt/decrypt a file.")
    p.add_argument('mode', choices=['encrypt', 'decrypt'], help="encrypt or decrypt (same operation for XOR)")
    p.add_argument('infile', type=Path, help="input file path")
    p.add_argument('outfile', type=Path, help="output file path")
    group = p.add_mutually_exclusive_group(required=True)
    group.add_argument('--key', help="passphrase (UTF-8) to derive key from")
    group.add_argument('--hex', help="raw hex key (e.g. 4a6f686e...)")
    p.add_argument('--key-len', type=int, default=32, help="derived key length in bytes (default 32)")
    args = p.parse_args()

    if args.key:
        key = derive_key_from_passphrase(args.key, length=args.key_len)
    else:
        key = parse_hex_key(args.hex)
        if len(key) < 1:
            raise SystemExit("Hex key must have at least one byte")

    # For XOR encrypt/decrypt the same function applies
    try:
        process_file(args.infile, args.outfile, key)
    except Exception as e:
        raise SystemExit(f"Error: {e}")

    print(f"{args.mode.title()}ion complete: {args.outfile}")


if __name__ == "__main__":
    main()
