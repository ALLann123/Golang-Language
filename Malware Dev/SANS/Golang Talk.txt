============GO FOR MALWARE DEVELOPMENT=================
What is GO?
- Is a general purpose computing language.
- Created by Google
- Gaming Apps, Server, RED-teaming tools e.g Merlin c2, Gobuster, Gophish
- Its fast as C and portability(run in multiple OS)
WHy GO in Cyber Sec?
- Used in a Circum navigate security controls.

------------Go Malware in the wild-----------
- Sandworm Team---> not petya
--->Kinsing is a notorious, persistent malware written in the Go (Golang) programming language that primarily targets Linux-based server and cloud environments for cryptocurrency mining
--->"EKANS" (also known as Snake) is a notorious ransomware variant, first identified in late 2019, that specifically targets Industrial Control Systems (ICS) environments. 
- How to use Go in Red Team.
 
===========Building Go like a Pro========================
-----------Wonders of Cross Compilation-------
- Develop on one OS and target all the other OS.
- We can target an Android or IOS in Go
- Supports over 20 common CPU architectures.

------------Go Binaries----------
- Go compiler produces a single native executable:
	exe, elf, Mach-O, DLL/ shared objects for linux
- Go binaries have no installations dependancies
	* Go compiler statically links Go runtime and needed packages
	---> Upload and Execute
DOWNSIDE: -When we link Statically it inflates payload size
	  - RATS are less than 20MB
NOTE: We have a tool to reduce this size.
---------> With Large Binaries it becomes harder to reverse engineer and AV
products cant configure.

------------Creating a Cross Platform Reverse Shell------------
- Let's build features using a simple reverse shell.
* Sends reverse shell every 3 seconds.
* Automatically detects OS and sends correct shell.
---------------------------------------------------------------
CODE: Cross_Plat_R_Shell/main.go
- Run as script
	cmd> go run main.go
- Compile for current OS e.g windows
	cmd> go build main.go
- Create a windows EXE from Linux
	kali>> GOOS=windows go build main.go
- Create a Linux ELF-- from windows
	PS> $env GOOS="linux"
	PS> go build .\main.go
Alternatively(GOARCH is optional but recomended):
	cmd> go build -o myprogram_linux.exe -ldflags "-s -w" -trimpath -v -x -gcflags "all=-N -l" -tags "linux" -installsuffix "linux" $env:GOOS="linux" $env:GOARCH="amd64" .\main.go
 NOTE: DLLs are more powerful because they are designed to be relocatable
============================POC===================================================================================================================================
Compiling for Linux:
	PS> $env:GOOS = "linux"
	PS> go build .\main.go

cmd> go run main.go
Simple Go Reverse Shell

msf6 post(multi/manage/shell_to_meterpreter) > sessions

Active sessions
===============

  Id  Name  Type                        Information                                                        Connection
  --  ----  ----                        -----------                                                        ----------
  2         shell sparc/bsd             Shell Banner: Windows PowerShell Copyright (C) Microsoft Corporat  192.168.1.108:4444 -> 192.168.1.106:51983 (192.168.1.106)
                                        ion. All ri...
  3         shell                                                                                          192.168.1.108:4444 -> 192.168.1.105:61623 (192.168.1.105)
  4         shell sparc/bsd             Shell Banner: Windows PowerShell Copyright (C) Microsoft Corporat  192.168.1.108:4444 -> 192.168.1.105:61627 (192.168.1.105)
                                        ion. All ri...
  5         shell sparc/bsd             Shell Banner: $ -----                                              192.168.1.108:4444 -> 192.168.1.101:42828 (192.168.1.101)
  6         meterpreter python/windows  DESKTOP-2VPR9IB\PC @ DESKTOP-2VPR9IB                               192.168.1.108:4433 -> 192.168.1.105:61748 (192.168.1.105)
=====================================================================================================================================================================


======================Building Dynamic Libraries=================
- Go makes it easy to create dynamic libraries
* Windows DLLs
* Linux shared objects
- Add two packages:
* Import C package.
* Export a function.
NOTE: Its easier to build DLLs from the appropriate windows System


===================Calling WinAPI=============================
- Calling winAPI in go allows us to tap into OS functions
* Provides greater stealth compared to spawning external processes
- Several ways to do this:
* Use Go's syscall package
* Use a library like w32(Binary size increases)
* Write code in C, compile into a go project.
NOTE: Build Rootkits and Bootkits to hide and maintain persistence.

===============Prevent Go Payloads from leaking Source Code===============
----------Strip The Binary---------
- Go compiler can omit debug symbols and strip the symbol table
* Defenders can no longer pull source code
* Variable names are converted to addresses(harder to reverse engineering)
* Bonus--It makes the binaries smaller
kali> go build -ldflags="-s -w" rshell.go


=====================Hiding Console Windows=============================
- Go programs usually display console windows on execution:
* We can hide the console window with a simple compiler flag
* This also suppresses the window on external processes
----------------------------------------------
//Run Powershell executes a command in Powershell
func RunPowershell(cmd string)([]byte, error){
	c:=exec.Command("powershell.exe", cmd)
	c.SysProcAttr = &syscall.SysProcAttr(HideWindow:true)
	output, err:=c.CombinedOutpu()
}
----------------------------------------------
- Or pass these flags to the compiler
	PS> go build -ldflags -H=windowsgui rshell.go
NOTE: This helps when we spawn other process they cannot appear on the screen
e.g notepad.exe when injected with shell code.(Process Hollowing)



==========================Advanced Red Teaming=============================
--------a) Memory-Reside Attacks--------------
 Dropper gets ===> Payload
- Sophisticated Payloads commonly exists in memory only
1. Reduces footprint on the target.
2. Makes it harder to recover and study payload.
- We can use our ability to compile windows DLLs and invoke the winAPI
to create an in-memory Go payloads. 
STEPS:
1. Compile your Go payload into DLL
2. Convert the DLL into shellcode using sRDI*
3. Install your shellcode into process memory
* You can do this in Go or any other shellcode loader

---------b) Calling Go Code from C---------------
- Convert our go code into a static library and link into C code.
- Once the above is archieved we can now call it from other languages
e.g Python.

